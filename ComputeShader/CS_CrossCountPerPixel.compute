#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;
int m_squareRadiusMax = 255;
int m_minToExist = 10;

int HasPixel(int x, int y)
{
    if (x < 0 || x >= m_width || y < 0 || y >= m_height)
        return 0;
    float4 color = m_source[int2(x, y)];
    if (color.a == 0.0f || (color.r == 0.0f && color.g == 0.0f && color.b == 0.0f))
        return 0;
    return 1;
}

int CountPixelAround(int x, int y)
{
    for (int pixelRadius = 1; pixelRadius <= m_squareRadiusMax; pixelRadius++)
    {
        int crossCount = HasPixel(x - pixelRadius, y);
        crossCount += HasPixel(x + pixelRadius, y);
        crossCount += HasPixel(x, y + pixelRadius);
        crossCount += HasPixel(x, y - pixelRadius);

        // Add diagonals
        crossCount += HasPixel(x - pixelRadius, y - pixelRadius);
        crossCount += HasPixel(x + pixelRadius, y - pixelRadius);
        crossCount += HasPixel(x - pixelRadius, y + pixelRadius);
        crossCount += HasPixel(x + pixelRadius, y + pixelRadius);
        
        if (crossCount != 8)
            return pixelRadius;
    }
    return m_squareRadiusMax;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    int count = CountPixelAround(id.x, id.y);
    float radiusCount = count / (float) m_squareRadiusMax;

    
    if (count > m_minToExist)
    {
        m_result[int2(id.x, id.y)] = float4(radiusCount, radiusCount, radiusCount, 1);
    }
    else
    {
        m_result[int2(id.x, id.y)] = float4(0,0,0,0);
    }
}
