#pragma kernel CSMain

// Input/Output textures
RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

// Shader parameters
int m_width;
int m_height;
float m_time;

#define m_mouse float2(2000,20)
#define m_thickness 6



// Get luminance average from source texture
float GetAve(float2 uv, float2 resolution)
{
    // Clamp UV coordinates to texture bounds
    uv = clamp(uv, float2(0, 0), float2(1, 1));
    
    // Convert UV to pixel coordinates
    int2 pixelCoord = int2(uv * resolution);
    
    float3 rgb = m_source[pixelCoord].rgb;
    float3 lum = float3(0.299, 0.587, 0.114);
    return dot(lum, rgb);
}

// Sobel edge detection
float4 Sobel(float2 fragCoord, float2 resolution, float2 dir)
{
    float2 uv = fragCoord / resolution;
    float2 texel = 1.0 / resolution;
    
    float thickness = max(m_thickness, 1.0);
    
    // Sample 3x3 neighborhood
    float np = GetAve(uv + (float2(-1, +1) + dir) * texel * thickness, resolution);
    float zp = GetAve(uv + (float2(0, +1) + dir) * texel * thickness, resolution);
    float pp = GetAve(uv + (float2(+1, +1) + dir) * texel * thickness, resolution);
    
    float nz = GetAve(uv + (float2(-1, 0) + dir) * texel * thickness, resolution);
    // zz = 0 (center pixel not used in Sobel)
    float pz = GetAve(uv + (float2(+1, 0) + dir) * texel * thickness, resolution);
    
    float nn = GetAve(uv + (float2(-1, -1) + dir) * texel * thickness, resolution);
    float zn = GetAve(uv + (float2(0, -1) + dir) * texel * thickness, resolution);
    float pn = GetAve(uv + (float2(+1, -1) + dir) * texel * thickness, resolution);
    
    // Sobel operators with enhanced weights
    float gx = (np * -3.0 + nz * -10.0 + nn * -3.0 + pp * 3.0 + pz * 10.0 + pn * 3.0);
    float gy = (np * -3.0 + zp * -10.0 + pp * -3.0 + nn * 3.0 + zn * 10.0 + pn * 3.0);
    
    float2 G = float2(gx, gy);
    float grad = length(G);
    float angle = atan2(G.y, G.x);
    
    return float4(G, grad, angle);
}

// Hysteresis thresholding for edge thinning
float2 HysteresisThr(float2 fragCoord, float2 resolution, float mn, float mx)
{
    float4 edge = Sobel(fragCoord, resolution, float2(0, 0));
    float2 dir = float2(cos(edge.w), sin(edge.w));
    dir *= float2(-1, 1); // rotate 90 degrees
    
    float4 edgep = Sobel(fragCoord, resolution, dir);
    float4 edgen = Sobel(fragCoord, resolution, -dir);
    
    // Non-maximum suppression
    if (edge.z < edgep.z || edge.z < edgen.z) 
        edge.z = 0.0;
    
    return float2(
        (edge.z > mn) ? edge.z : 0.0,
        (edge.z > mx) ? edge.z : 0.0
    );
}

// Complete Canny edge detection
float CannyEdge(float2 fragCoord, float2 resolution, float mn, float mx)
{
    // Sample 3x3 neighborhood for hysteresis
    float2 np = HysteresisThr(fragCoord + float2(-1, +1), resolution, mn, mx);
    float2 zp = HysteresisThr(fragCoord + float2(0, +1), resolution, mn, mx);
    float2 pp = HysteresisThr(fragCoord + float2(+1, +1), resolution, mn, mx);
    
    float2 nz = HysteresisThr(fragCoord + float2(-1, 0), resolution, mn, mx);
    float2 zz = HysteresisThr(fragCoord + float2(0, 0), resolution, mn, mx);
    float2 pz = HysteresisThr(fragCoord + float2(+1, 0), resolution, mn, mx);
    
    float2 nn = HysteresisThr(fragCoord + float2(-1, -1), resolution, mn, mx);
    float2 zn = HysteresisThr(fragCoord + float2(0, -1), resolution, mn, mx);
    float2 pn = HysteresisThr(fragCoord + float2(+1, -1), resolution, mn, mx);
    
    // Edge connectivity and final result
    float neighborSum = np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y;
    return min(1.0, step(1e-2, zz.x * 8.0) * smoothstep(0.0, 0.3, neighborSum) * 8.0);
}


// Thread group size
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) m_width || id.y >= (uint) m_height)
        return;

    float2 fragCoord = float2(id.x, id.y);
    float2 resolution = float2(m_width, m_height);
    
    float2 mous = m_mouse / resolution.xy * 0.1;
    float minThreshold = mous.x * 15.0;
    float maxThreshold = mous.y * 90.0;
    
    float edge = CannyEdge(fragCoord, resolution, minThreshold, maxThreshold);
    
    float3 col = lerp(float3(1.0, 1.0, 1.0), float3(0.0, 0.0, 0.0), 1.0 - edge);
    m_result[id.xy] = float4(col, 1.0);
}
