#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;

// Constants
#define RADIUS 150.0
#define INV_SQRT_2PI_X3 1.1968268412042980338198381798031

float4 blur(float2 uv, float2 texelOffset)
{
    float r = RADIUS;
    float exp_value = -4.5 / (r * r);
    float sqrt_value = INV_SQRT_2PI_X3 / r;

    float sum = 0.0;
    float4 value = float4(0.0, 0.0, 0.0, 0.0);

    for (float x = 1.0; x <= r; x += 1.0)
    {
        float scale = exp(exp_value * x * x);
        sum += scale;

        float2 offset = texelOffset * x;
        float2 uv_minus = uv - offset;
        float2 uv_plus = uv + offset;

        // Sample manually using pixel coords
        int2 coord_minus = int2(clamp(uv_minus * float2(m_width, m_height), 0.0, float2(m_width - 1, m_height - 1)));
        int2 coord_plus = int2(clamp(uv_plus * float2(m_width, m_height), 0.0, float2(m_width - 1, m_height - 1)));

        value += scale * (m_source[coord_minus] + m_source[coord_plus]);
    }

    float2 uv_pix = uv * float2(m_width, m_height);
    int2 center_coord = int2(clamp(uv_pix, 0.0, float2(m_width - 1, m_height - 1)));

    float correction = 1.0 / sqrt_value - 2.0 * sum;
    value += m_source[center_coord] * correction;

    return value * sqrt_value;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    float2 uv = float2(id.xy) / float2(m_width, m_height);

    float2 texel = float2(1.0 / m_width, 0.0); // Horizontal blur
    float4 outColor = blur(uv, texel);

    // Optional lighting mix as in original shader
    float light = 0.7;
    float alpha = 0.3;
    float4 mixColor = float4(light, light, light, 0.5);

    m_result[id.xy] = lerp(outColor, mixColor, alpha);
}
