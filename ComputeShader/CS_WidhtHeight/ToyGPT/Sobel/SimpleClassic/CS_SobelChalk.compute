#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;

// Convert RGB to grayscale intensity
float intensity(float3 pixel)
{
    return (pixel.r + pixel.g + pixel.b) / 3.0;
}

// Sample grayscale intensity at an offset
float pixelIntensity(int2 baseCoord, int2 offset)
{
    int2 coord = clamp(baseCoord + offset, int2(0, 0), int2(m_width - 1, m_height - 1));
    float3 rgb = m_source[coord].rgb;
    return intensity(rgb);
}

// Convolve two 3x3 matrices
float convolv(float3x3 a, float3x3 b)
{
    float result = 0.0;
    [unroll]
    for (int i = 0; i < 3; i++)
    {
        [unroll]
        for (int j = 0; j < 3; j++)
        {
            result += a[i][j] * b[i][j];
        }
    }
    return result;
}

// Apply Sobel filter at the given pixel coordinate
float sobel(int2 coord)
{
    float3x3 gx =
    {
        1.0, 2.0, 1.0,
         0.0, 0.0, 0.0,
        -1.0, -2.0, -1.0
    };

    float3x3 gy =
    {
        -1.0, 0.0, 1.0,
        -2.0, 0.0, 2.0,
        -1.0, 0.0, 1.0
    };

    float3x3 sample = float3x3(0.0, 0.0, 0.0,
                               0.0, 0.0, 0.0,
                               0.0, 0.0, 0.0);

    [unroll]
    for (int y = -1; y <= 1; y++)
    {
        [unroll]
        for (int x = -1; x <= 1; x++)
        {
            sample[x + 1][y + 1] = pixelIntensity(coord, int2(x, y));
        }
    }

    float sx = convolv(gx, sample);
    float sy = convolv(gy, sample);

    return sqrt(sx * sx + sy * sy);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    int2 coord = int2(id.xy);
    float s = sobel(coord);
    float color = max(s, 0.0); // raw sobel result
    m_result[coord] = float4(color, color, color, 1.0); // grayscale with alpha = 1
}
