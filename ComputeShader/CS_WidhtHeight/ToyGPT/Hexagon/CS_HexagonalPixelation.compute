// Main compute shader kernel
#pragma kernel CSMain

// Input texture (source image)
RWTexture2D<float4> m_source;
// Output texture (result image)
RWTexture2D<float4> m_result;

// Texture width and height (set externally)
int m_width;
int m_height;

// Number of hexagonal tilings across the image
#define TILINGS 60.0

// Computes the distance from a point to the edge of a hexagon
float hexDist(float2 p)
{
    p = abs(p);
    // Project point onto hexagon edge direction
    float edgeDist = dot(p, normalize(float2(1.0, 1.7320508)));
    // Return the maximum distance to the edge or x-axis
    return max(edgeDist, p.x);
}

// Main compute shader function
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Early exit if thread is outside the image bounds
    if (id.x >= m_width || id.y >= m_height)
        return;
    
    float widthOfHexagon = m_width / TILINGS;

    // Image resolution as float2
    float2 iResolution = float2(m_width, m_height);

    // Pixel center coordinateswe  ew
    float2 fragCoord = float2(id.xy) ;

    // Calculate aspect ratio to keep hexagons regular
    float aspect = iResolution.x / iResolution.y;
    // Map pixel to UV space, scale by tilings and aspect
    float2 uv = fragCoord / iResolution.xy * float2(aspect, 1.0) * TILINGS;

    // Hexagon repetition vector (width, height)
    float2 rep = float2(1.0, 1.7320508);
    // Unit size of a hexagon in UV space
    float unit = 2.0 * TILINGS / iResolution.y;
    // Half repetition vector
    float2 hrep = 0.5 * rep;

    // Calculate two possible hexagon centers
    float2 a = fmod(uv, rep) - hrep;
    float2 b = fmod(uv - hrep, rep) - hrep;

    // Squared distances to the two centers
    float aDist = dot(a, a);
    float bDist = dot(b, b);

    // Choose the closest hexagon center
    float2 hexUv = aDist < bDist ? a : b;
    // Get the cell (hexagon) ID in UV space
    float2 cellId = uv - hexUv;

    // Calculate sample UV in [0,1] range
    float2 sampleUv = cellId / TILINGS;
    // Correct for aspect ratio
    sampleUv.x /= aspect;

    // Shift sample UV by 0.5 to center
    float2 samplePosUV = sampleUv ;

    // Convert sample UV to pixel coordinates
    int2 samplePos = int2(samplePosUV * iResolution);

    // Clamp sample position to texture bounds
    samplePos = clamp(samplePos, int2(0, 0), int2(m_width - 1, m_height - 1));

    // Sample the color from the source texture
    float4 sampledColor = m_source.Load(int3(samplePos, 0));

    // Compute brightness as average of RGB
    float brightness = dot(sampledColor.rgb, float3(0.3333333, 0.3333333, 0.3333333));

    // Compute edge distance, modulated by brightness
    float edge = hexDist(hexUv) - brightness * 0.5;

    // Smooth alpha for anti-aliased hexagon edge
    float alpha = smoothstep(unit, 0.0, edge);

    // Write result as grayscale with full alpha
    m_result[id.xy] = float4(alpha, alpha, alpha, 1.0);
}
