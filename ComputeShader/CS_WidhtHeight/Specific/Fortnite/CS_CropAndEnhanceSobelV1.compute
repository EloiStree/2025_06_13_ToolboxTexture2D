#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;
float m_time;

#define percent_left 0.40
#define percent_right 0.40
#define percent_top 0.40
#define percent_down 0.40

#define SOBEL_RADIUS 1 // 1 for 3x3, 2 for 5x5, etc.

// For 3x3 kernel (radius 1), standard Sobel weights
static const float sobel_x[3][3] = {
    { -1, 0, 1 },
    { -2, 0, 2 },
    { -1, 0, 1 }
};
static const float sobel_y[3][3] = {
    { -1, -2, -1 },
    {  0,  0,  0 },
    {  1,  2,  1 }
};

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    int out_x = id.x;
    int out_y = id.y;

    // === Crop + Resize Mapping ===
    float crop_left = percent_left;
    float crop_right = 1.0 - percent_right;
    float crop_top = percent_top;
    float crop_bottom = 1.0 - percent_down;

    float cropped_width = crop_right - crop_left;
    float cropped_height = crop_bottom - crop_top;

    float u = (float) out_x / (float) m_width;
    float v = (float) out_y / (float) m_height;

    float src_u = crop_left + u * cropped_width;
    float src_v = crop_top + v * cropped_height;

    float2 sourceUV = float2(src_u, src_v) * float2(m_width, m_height);
    int2 center = int2(sourceUV + 0.5);

    // === Sobel Sampling (with configurable size) ===
    float gx = 0.0;
    float gy = 0.0;
    
    // 3x3 Sobel
    [unroll]
    for (int j = -1; j <= 1; ++j)
    {
        [unroll]
        for (int i = -1; i <= 1; ++i)
        {
            int2 offset = int2(i, j);
            int2 sampleCoord = clamp(center + offset, int2(0, 0), int2(m_width - 1, m_height - 1));
            float3 sample = m_source[sampleCoord].rgb;
            float gray = dot(sample, float3(0.299, 0.587, 0.114));
            gx += gray * sobel_x[j + 1][i + 1];
            gy += gray * sobel_y[j + 1][i + 1];
        }
    }

    float edge = sqrt(gx * gx + gy * gy);
    edge = saturate(edge);

    float4 sobelColor = float4(edge.xxx, 1.0);

    // === Keep image color where not white sobel ===
    float4 srcColor = m_source[clamp(center, int2(0, 0), int2(m_width - 1, m_height - 1))];
    float threshold = 0.99; // treat "white" as edge >= 0.99
    float4 color = lerp(srcColor, sobelColor, step(threshold, edge));

    // === Overlay a red cross ===
    int2 center_coord = int2(m_width / 2, m_height / 2);
    int thickness = 2;

    bool is_vertical_cross = abs(out_x - center_coord.x) < thickness;
    bool is_horizontal_cross = abs(out_y - center_coord.y) < thickness;

    if (is_vertical_cross || is_horizontal_cross)
    {
        color = float4(1, 0, 0, 0.5); // red
    }

    if (color.r < 0.1 && color.g < 0.1 && color.b < 0.1)
    {
        color.a = 0.0;
    }
    // === Final Write ===
    m_result[int2(out_x, out_y)] = color;
}
