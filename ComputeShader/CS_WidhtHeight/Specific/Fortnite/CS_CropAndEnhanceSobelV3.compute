#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;
float m_time;

#define percent_left 0.40
#define percent_right 0.40
#define percent_top 0.40
#define percent_down 0.40

#define SOBEL_RADIUS 1 // 1 for 3x3, 2 for 5x5, etc.

// For 3x3 kernel (radius 1), standard Sobel weights
static const float sobel_x[3][3] =
{
    { -1, 0, 1 },
    { -2, 0, 2 },
    { -1, 0, 1 }
};
static const float sobel_y[3][3] =
{
    { -1, -2, -1 },
    { 0, 0, 0 },
    { 1, 2, 1 }
};

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    int out_x = id.x;
    int out_y = id.y;

    float crop_left = percent_left;
    float crop_right = 1.0 - percent_right;
    float crop_top = percent_top;
    float crop_bottom = 1.0 - percent_down;

    float cropped_width = crop_right - crop_left;
    float cropped_height = crop_bottom - crop_top;

    float u = (float) out_x / (float) m_width;
    float v = (float) out_y / (float) m_height;

    float src_u = crop_left + u * cropped_width;
    float src_v = crop_top + v * cropped_height;

    float2 sourceUV = float2(src_u, src_v) * float2(m_width, m_height);

    float2 uv_floor = floor(sourceUV);
    float2 uv_frac = sourceUV - uv_floor;

    int2 p0 = int2(uv_floor);
    int2 p1 = int2(p0.x + 1, p0.y);
    int2 p2 = int2(p0.x, p0.y + 1);
    int2 p3 = int2(p0.x + 1, p0.y + 1);

    p0 = clamp(p0, int2(0, 0), int2(m_width - 1, m_height - 1));
    p1 = clamp(p1, int2(0, 0), int2(m_width - 1, m_height - 1));
    p2 = clamp(p2, int2(0, 0), int2(m_width - 1, m_height - 1));
    p3 = clamp(p3, int2(0, 0), int2(m_width - 1, m_height - 1));

    float4 c0 = m_source[p0];
    float4 c1 = m_source[p1];
    float4 c2 = m_source[p2];
    float4 c3 = m_source[p3];

    float4 c01 = lerp(c0, c1, uv_frac.x);
    float4 c23 = lerp(c2, c3, uv_frac.x);
    float4 bilinearColor = lerp(c01, c23, uv_frac.y);

    // === Sobel Sampling (3x3) ===
    int2 center = clamp(int2(sourceUV), int2(0, 0), int2(m_width - 1, m_height - 1));

    float gx = 0.0;
    float gy = 0.0;

    [unroll]
    for (int j = -1; j <= 1; ++j)
    {
        [unroll]
        for (int i = -1; i <= 1; ++i)
        {
            int2 offset = int2(i, j);
            int2 sampleCoord = clamp(center + offset, int2(0, 0), int2(m_width - 1, m_height - 1));
            float3 sample = m_source[sampleCoord].rgb;
            float gray = dot(sample, float3(0.299, 0.587, 0.114));
            gx += gray * sobel_x[j + 1][i + 1];
            gy += gray * sobel_y[j + 1][i + 1];
        }
    }

    float edge = sqrt(gx * gx + gy * gy);
    edge = saturate(edge);

    float4 sobelColor = float4(edge.xxx, 1.0);

    float threshold = 0.99;
    float4 srcColor = bilinearColor;

    float4 finalColor = lerp(srcColor, sobelColor, step(threshold, edge));

    bool isPixelWhiteInGame = srcColor.r > 0.9 && srcColor.g > 0.9 && srcColor.b > 0.9;
    bool isPixelAfterEffectWhite = finalColor.r > 0.9 && finalColor.g > 0.9 && finalColor.b > 0.9;

    if (!isPixelWhiteInGame && isPixelAfterEffectWhite)
        finalColor = float4(1, 0, 0, 1);

    // === Overlay a red cross ===
    int2 center_coord = int2(m_width / 2, m_height / 2);
    int thickness = 1;

    bool is_vertical_cross = abs(out_x - center_coord.x) < thickness;
    bool is_horizontal_cross = abs(out_y - center_coord.y) < thickness;

    if (is_vertical_cross || is_horizontal_cross)
    {
        finalColor = float4(1, 0, 0, 1); // red
    }

    // === Final Write ===
    m_result[int2(out_x, out_y)] = finalColor;
}
