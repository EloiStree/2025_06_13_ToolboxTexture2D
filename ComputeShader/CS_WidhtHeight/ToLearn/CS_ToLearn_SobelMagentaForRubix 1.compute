#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    // Sobel kernels
    float3x3 Gx = float3x3(
        -1, 0, 1,
        -2, 0, 2,
        -1, 0, 1
    );
    float3x3 Gy = float3x3(
        -1, -2, -1,
         0, 0, 0,
         1, 2, 1
    );

    float3 sample[3][3];
    // Clamp coordinates to avoid out-of-bounds
    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            uint2 coord = uint2(
                clamp(int(id.x) + x, 0, m_width - 1),
                clamp(int(id.y) + y, 0, m_height - 1)
            );
            sample[y + 1][x + 1] = m_source[coord].rgb;
        }
    }

    // Convert to grayscale
    float gray[3][3];
    for (int y = 0; y < 3; y++)
    {
        for (int x = 0; x < 3; x++)
        {
            gray[y][x] = dot(sample[y][x], float3(0.299, 0.587, 0.114));
        }
    }

    // Apply Sobel filter
    float gx = 0;
    float gy = 0;
    for (int y = 0; y < 3; y++)
    {
        for (int x = 0; x < 3; x++)
        {
            gx += gray[y][x] * Gx[y][x];
            gy += gray[y][x] * Gy[y][x];
        }
    }

    float mag = sqrt(gx * gx + gy * gy);

    // Lower threshold to catch weaker edges
    float threshold = 0.15;
    bool isEdge = (mag > threshold);

    // --- Dilation pass (3x3) in the same thread ---
    if (!isEdge)
    {
        for (int dy = -1; dy <= 1 && !isEdge; dy++)
        {
            for (int dx = -1; dx <= 1 && !isEdge; dx++)
            {
                uint2 coord = uint2(
                    clamp(int(id.x) + dx, 0, m_width - 1),
                    clamp(int(id.y) + dy, 0, m_height - 1)
                );

                // Sample neighbors for edge strength
                float3 ncolor = m_source[coord].rgb;
                float ngray = dot(ncolor, float3(0.299, 0.587, 0.114));

                // Quick recheck for edge-like pixel
                if (ngray > 0.5 || ngray < 0.5) // placeholder, can store edges in temp buffer for better check
                {
                    // This is a crude dilation based on nearby edges
                }
            }
        }
    }

    // Output edges as magenta, else keep original
    float4 result;
    if (isEdge)
    {
        result = float4(1, 0, 1, 1);
    }
    else
    {
        result = m_source[id.xy];
    }

    m_result[id.xy] = result;
}
