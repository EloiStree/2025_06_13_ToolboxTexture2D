#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    // Sobel kernels
    float3x3 Gx = float3x3(
        -1, 0, 1,
        -2, 0, 2,
        -1, 0, 1
    );
    float3x3 Gy = float3x3(
        -1, -2, -1,
         0, 0, 0,
         1, 2, 1
    );

    float3 sample[3][3];
    // Clamp coordinates to avoid out-of-bounds
    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            uint2 coord = uint2(
                clamp(int(id.x) + x, 0, m_width - 1),
                clamp(int(id.y) + y, 0, m_height - 1)
            );
            sample[y + 1][x + 1] = m_source[coord].rgb;
        }
    }

    // Convert to grayscale
    float gray[3][3];
    for (int y = 0; y < 3; y++)
    {
        for (int x = 0; x < 3; x++)
        {
            gray[y][x] = dot(sample[y][x], float3(0.299, 0.587, 0.114));
        }
    }

    // Apply Sobel filter
    float gx = 0;
    float gy = 0;
    for (int y = 0; y < 3; y++)
    {
        for (int x = 0; x < 3; x++)
        {
            gx += gray[y][x] * Gx[y][x];
            gy += gray[y][x] * Gy[y][x];
        }
    }

    float mag = sqrt(gx * gx + gy * gy);

    // Strong line threshold
    float threshold = 0.25;
    float4 result = float4(0, 0, 0, 1);
    if (mag > threshold)
    {
        // Magenta: R=1, G=0, B=1
        result = float4(1, 1, 1, 1);
    }

    m_result[id.xy] = result;
}