// SOURCe https://claude.ai/public/artifacts/edbaa2ee-8af2-4099-b0cb-58470a81010a

#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;
float m_time;

// RGB to HSV conversion
float3 RGBtoHSV(float3 rgb)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(rgb.bg, K.wz), float4(rgb.gb, K.xy), step(rgb.b, rgb.g));
    float4 q = lerp(float4(p.xyw, rgb.r), float4(rgb.r, p.yzx), step(p.x, rgb.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// RGB to HSL conversion
float3 RGBtoHSL(float3 rgb)
{
    float maxVal = max(max(rgb.r, rgb.g), rgb.b);
    float minVal = min(min(rgb.r, rgb.g), rgb.b);
    float delta = maxVal - minVal;
    
    float h = 0.0;
    float s = 0.0;
    float l = (maxVal + minVal) * 0.5;
    
    if (delta > 0.0001)
    {
        // Calculate saturation
        s = (l < 0.5) ? delta / (maxVal + minVal) : delta / (2.0 - maxVal - minVal);
        
        // Calculate hue
        if (maxVal == rgb.r)
            h = ((rgb.g - rgb.b) / delta) + (rgb.g < rgb.b ? 6.0 : 0.0);
        else if (maxVal == rgb.g)
            h = (rgb.b - rgb.r) / delta + 2.0;
        else
            h = (rgb.r - rgb.g) / delta + 4.0;
        
        h /= 6.0;
    }
    
    return float3(h, s, l);
}

// Color identification function
int IdentifyColor(float3 rgb, float3 hsv, float3 hsl)
{
    float brightness = max(max(rgb.r, rgb.g), rgb.b);
    float saturation = hsv.y;
    float hue = hsv.x;
    
    // Thresholds
    float brightThreshold = 0.8;
    float darkThreshold = 0.2;
    float satThreshold = 0.3;
    
    // Black: low brightness
    if (brightness < darkThreshold)
        return 1; // Black
    
    // White: high brightness, low saturation
    if (brightness > brightThreshold && saturation < satThreshold)
        return 0; // White
    
    // For colored pixels, check saturation first
    if (saturation < satThreshold)
        return 0; // Treat as white/gray
    
    // Color identification based on hue ranges
    // Red (includes red, orange, yellow): 0-90° and 300-360° (0.0-0.25 and 0.833-1.0)
    if ((hue >= 0.0 && hue <= 0.25) || (hue >= 0.833 && hue <= 1.0))
        return 2; // Red
    
    // Green: 90-180° (0.25-0.5)
    if (hue >= 0.25 && hue <= 0.5)
        return 3; // Green
    
    // Blue: 180-300° (0.5-0.833)
    if (hue >= 0.5 && hue <= 0.833)
        return 4; // Blue
    
    // Default to white if no specific color is detected
    return 0;
}

// Get color based on ID
float4 GetColorFromID(int colorID, float3 originalRGB)
{
    // Color palette for visualization (simplified to 5 colors)
    float4 colors[5] =
    {
        float4(1.0, 1.0, 1.0, 1.0), // White
        float4(0.0, 0.0, 0.0, 1.0), // Black
        float4(1.0, 0.0, 0.0, 1.0), // Red (includes yellow, orange, red)
        float4(0.0, 1.0, 0.0, 1.0), // Green
        float4(0.0, 0.0, 1.0, 1.0) // Blue
    };
    
    return colors[colorID];
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) m_width || id.y >= (uint) m_height)
        return;
    
    // Sample the source texture
    float4 sourceColor = m_source[id.xy];
    float3 rgb = sourceColor.rgb;
    
    // Convert to HSV and HSL
    float3 hsv = RGBtoHSV(rgb);
    float3 hsl = RGBtoHSL(rgb);
    
    // Identify the dominant color
    int colorID = IdentifyColor(rgb, hsv, hsl);
    
    // Get the result color
    float4 resultColor = GetColorFromID(colorID, rgb);
    
    // Optional: Add some animation or effects using m_time
    // For example, you could add a pulsing effect or color cycling
    
    // Write to result texture
    m_result[id.xy] = float4(resultColor.rgb, sourceColor.a);
}