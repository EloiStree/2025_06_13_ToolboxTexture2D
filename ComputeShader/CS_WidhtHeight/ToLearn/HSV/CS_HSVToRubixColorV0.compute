#pragma kernel CSMain

RWTexture2D<float3> m_source; // RGB input
RWTexture2D<float3> m_result; // Output: classified color

int m_width;
int m_height;
float m_time;

// ---- HSV Ranges ----
// Red: wrap-around range for hue
static const float4 RED_RANGE = float4(0.96, 0.04, 0.4, 1.0); // Hmin, Hmax, Smin, Smax
static const float2 RED_V = float2(0.2, 1.0); // Vmin, Vmax

// Orange
static const float4 ORANGE_RANGE = float4(0.04, 0.10, 0.4, 1.0);
static const float2 ORANGE_V = float2(0.3, 1.0);

// Yellow
static const float4 YELLOW_RANGE = float4(0.10, 0.17, 0.4, 1.0);
static const float2 YELLOW_V = float2(0.4, 1.0);

// Green
static const float4 GREEN_RANGE = float4(0.20, 0.45, 0.35, 1.0);
static const float2 GREEN_V = float2(0.2, 1.0);

// Blue
static const float4 BLUE_RANGE = float4(0.55, 0.75, 0.35, 1.0);
static const float2 BLUE_V = float2(0.2, 1.0);

// White (ignore hue)
static const float WHITE_S_MAX = 0.15; // very low saturation
static const float2 WHITE_V = float2(0.75, 1.0);

float3 RGBToHSV(float3 c)
{
    float r = c.r, g = c.g, b = c.b;
    float maxc = max(r, max(g, b));
    float minc = min(r, min(g, b));
    float delta = maxc - minc;

    float h = 0.0;
    if (delta > 1e-6)
    {
        if (maxc == r)
            h = (g - b) / delta;
        else if (maxc == g)
            h = ((b - r) / delta) + 2.0;
        else
            h = ((r - g) / delta) + 4.0;

        h /= 6.0;
        if (h < 0)
            h += 1.0;
    }

    float s = (maxc <= 1e-6) ? 0.0 : (delta / maxc);
    float v = maxc;

    return float3(h, s, v);
}

bool InHueRange(float h, float hmin, float hmax)
{
    return (hmin <= hmax) ? (h >= hmin && h <= hmax) : (h >= hmin || h <= hmax);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    // 1. Read RGB
    float3 rgb = m_source[id.xy];

    // 2. Convert to HSV
    float3 hsv = RGBToHSV(rgb);

    // 3. Classify
    float3 label = float3(0, 0, 0); // default black

    // White
    if (hsv.y <= WHITE_S_MAX && hsv.z >= WHITE_V.x && hsv.z <= WHITE_V.y)
        label = float3(1, 1, 1);

    // Blue
    if (InHueRange(hsv.x, BLUE_RANGE.x, BLUE_RANGE.y) &&
        hsv.y >= BLUE_RANGE.z && hsv.y <= BLUE_RANGE.w &&
        hsv.z >= BLUE_V.x && hsv.z <= BLUE_V.y)
        label = float3(0, 0, 1);

    // Green
    if (InHueRange(hsv.x, GREEN_RANGE.x, GREEN_RANGE.y) &&
        hsv.y >= GREEN_RANGE.z && hsv.y <= GREEN_RANGE.w &&
        hsv.z >= GREEN_V.x && hsv.z <= GREEN_V.y)
        label = float3(0, 1, 0);

    // Yellow
    if (InHueRange(hsv.x, YELLOW_RANGE.x, YELLOW_RANGE.y) &&
        hsv.y >= YELLOW_RANGE.z && hsv.y <= YELLOW_RANGE.w &&
        hsv.z >= YELLOW_V.x && hsv.z <= YELLOW_V.y)
        label = float3(1, 1, 0);

    // Orange
    if (InHueRange(hsv.x, ORANGE_RANGE.x, ORANGE_RANGE.y) &&
        hsv.y >= ORANGE_RANGE.z && hsv.y <= ORANGE_RANGE.w &&
        hsv.z >= ORANGE_V.x && hsv.z <= ORANGE_V.y)
        label = float3(1, 0.5, 0);

    // Red
    if (InHueRange(hsv.x, RED_RANGE.x, RED_RANGE.y) &&
        hsv.y >= RED_RANGE.z && hsv.y <= RED_RANGE.w &&
        hsv.z >= RED_V.x && hsv.z <= RED_V.y)
        label = float3(1, 0, 0);

    // 4. Write result
    m_result[id.xy] = label;
}
