// NoiseComputeShader.compute
#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;

int m_width;
int m_height;
float m_time;

// Constants
static const uint3 k = uint3(0x456789abu, 0x6789ab45u, 0x89ab4567u);
static const uint3 u = uint3(1, 2, 3);
static const uint M = 2400000000u;

uint2 h(uint2 n)
{
    n ^= (n.yx << u.xy);
    n ^= (n.yx >> u.xy);
    n *= k.xy;
    n ^= (n.yx << u.xy);
    return n * k.xy;
}

float s(float2 p)
{
    uint2 n = uint2(p.x, p.y);
    return float(h(n).x) / float(M);
}

float gt(float2 l, float2 p)
{
    uint2 n = uint2(l.x, l.y);
    uint i = h(n).x >> 29;
    float u = 0.92387953 * (i < 4 ? p.x : p.y);
    float v = 0.38268343 * (i < 4 ? p.y : p.x);
    return ((i & 1u) == 0u ? u : -u) + ((i & 2u) == 0u ? v : -v);
}

float vn(float2 p)
{
    float2 n = floor(p);
    float v[4];
    for (int j = 0; j < 2; j++)
    {
        for (int i = 0; i < 2; i++)
        {
            v[i + 2 * j] = s(n + float2(i, j));
        }
    }
    float2 f = frac(p);
    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);
    return lerp(lerp(v[0], v[1], f.x), lerp(v[2], v[3], f.x), f.y);
}

float pn(float2 p)
{
    float2 n = floor(p);
    float2 f = frac(p);
    float v[4];
    for (int j = 0; j < 2; j++)
    {
        for (int i = 0; i < 2; i++)
        {
            v[i + 2 * j] = gt(n + float2(i, j), f - float2(i, j));
        }
    }
    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);
    return lerp(lerp(v[0], v[1], f.x), lerp(v[2], v[3], f.x), f.y) + 0.5;
}

float fbm(float2 p, float g)
{
    float val = 0.0;
    float amp = 1.0;
    float freq = 1.0;
    for (int i = 0; i < 4; i++)
    {
        val += amp * (vn(freq * p) - 0.5);
        amp *= g;
        freq *= 2.01;
    }
    // Normalize to [0,1] range
    return saturate(0.5 * val + 0.5);
}

float bs(float2 p)
{
    return fbm(p, 0.5);
}

float cv(float v)
{
    return v;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;
    float2 uv = float2(id.x, id.y) / float2(m_width - 1, m_height - 1);
    // Animate noise by offsetting with time and add a bit of randomness
    float randomSeed = frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453 + m_time);
    float2 noiseUV = uv * 16.0 + float2(m_time, m_time * 0.5) + randomSeed;
    float n = bs(noiseUV);

    // Amplify the cloud noise effect (double effect)
    n = saturate((n - 0.5) * 6 + 0.5); // First amplification
   // n = saturate((n - 0.1) * 1.6 + 0.1); // Second amplification (double effect)

    float4 src = m_source[id.xy]; // Read from source texture
    // Convert source color to grayscale
    float gray = dot(src.rgb, float3(0.299, 0.587, 0.114)*0.2);
    // Make it more white by blending towards white
    float whiteness = 0.3; // 0 = gray, 1 = white
    float3 col = lerp(float3(gray, gray, gray), float3(1, 1, 1)*1, whiteness);

    // Blend amplified noise into the color for a stronger cloud effect
    float3 finalCol = lerp(col, float3(1, 1, 1), n * 0.1);

    // Inverse final color
    finalCol = 1.0 - finalCol;

    m_result[id.xy] = float4(finalCol, 1);
}
