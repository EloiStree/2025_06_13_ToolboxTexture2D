#pragma kernel CSMain

RWTexture2D<float4> m_source;
RWTexture2D<float4> m_result;
int m_width;
int m_height;
int m_squareRadius = 5;
int m_minToExist = 10;
int m_removeSinglePixel = 1;

// Vérifie s'il y a un pixel non transparent/non noir aux coordonnées données
int HasPixel(int x, int y)
{
    if (x < 0 || x >= m_width || y < 0 || y >= m_height)
        return 0;
    float4 color = m_source[int2(x, y)];
    if (color.a == 0.0f || (color.r == 0.0f && color.g == 0.0f && color.b == 0.0f))
        return 0;
    return 1;
}

// Compte les pixels non transparents autour d’un point dans un carré
int CountPixelAround(int x, int y)
{
    int count = 0;
    for (int xx = x - m_squareRadius; xx <= x + m_squareRadius; xx++)
    {
        for (int yy = y - m_squareRadius; yy <= y + m_squareRadius; yy++)
        {
            if (xx == x && yy == y)
                continue; 
            count += HasPixel(xx, yy);
        }
    }
    return count;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= m_width || id.y >= m_height)
        return;

    float4 color = m_source[int2(id.x, id.y)];
    if (color.a == 0.0f || (color.r == 0.0f && color.g == 0.0f && color.b == 0.0f))
    {
        m_result[int2(id.x, id.y)] = float4(0, 0, 0, 0);
        return;
    }

    if (m_removeSinglePixel > 0)
    {
        int neighborCount = CountPixelAround(id.x, id.y);
        if (neighborCount <= 2)
        {
            m_result[int2(id.x, id.y)] = float4(0, 0, 0, 0);
            return;
        }
    }

    int zoneCount = CountPixelAround(id.x, id.y);
    if (zoneCount < m_minToExist)
    {
        m_result[int2(id.x, id.y)] = float4(0, 0, 0, 0);
        return;
    }

    m_result[int2(id.x, id.y)] = color;
}
